================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-11-11T02:16:00.931Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.eslintrc.js
.gitignore
package.json
src/index.ts
tsconfig.dev.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .eslintrc.js
================
module.exports = {
  root: true,
  env: {
    es6: true,
    node: true,
  },
  extends: [
    "eslint:recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:import/typescript",
    "google",
    "plugin:@typescript-eslint/recommended",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    project: ["tsconfig.json", "tsconfig.dev.json"],
    sourceType: "module",
  },
  ignorePatterns: [
    "/lib/**/*", // Ignore built files.
    "/generated/**/*", // Ignore generated files.
  ],
  plugins: [
    "@typescript-eslint",
    "import",
  ],
  rules: {
    "quotes": ["error", "double"],
    "import/no-unresolved": 0,
    "indent": ["error", 2],
    "object-curly-spacing": "off",
    "@typescript-eslint/no-non-null-assertion": "off",
    "@typescript-eslint/no-explicit-any": "off",

  },
};

================
File: .gitignore
================
# Compiled JavaScript files
lib/**/*.js
lib/**/*.js.map

# TypeScript v1 declaration files
typings/

# Node.js dependency directory
node_modules/
*.local

================
File: package.json
================
{
  "name": "functions",
  "scripts": {
    "lint": "eslint --ext .js,.ts .",
    "build": "tsc",
    "build:watch": "tsc --watch",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "lib/index.js",
  "dependencies": {
    "@google-cloud/storage": "^7.13.0",
    "@google-cloud/video-transcoder": "^3.3.0",
    "firebase-admin": "^11.0.0",
    "firebase-functions": "^4.9.0",
    "functions": "file:"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.12.0",
    "@typescript-eslint/parser": "^5.12.0",
    "eslint": "^8.9.0",
    "eslint-config-google": "^0.14.0",
    "eslint-plugin-import": "^2.25.4",
    "firebase-functions-test": "^3.1.0",
    "typescript": "^4.9.0"
  },
  "private": true
}

================
File: tsconfig.dev.json
================
{
  "include": [
    ".eslintrc.js"
  ]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "es2017"
  },
  "compileOnSave": true,
  "include": [
    "src"
  ]
}

================
File: src/index.ts
================
import * as functions from "firebase-functions";
import { initializeApp } from "firebase-admin/app";
import { Firestore } from "firebase-admin/firestore";
import * as logger from "firebase-functions/logger";
import { Storage } from "@google-cloud/storage";
import { onCall } from "firebase-functions/v2/https";
import { TranscoderServiceClient } from "@google-cloud/video-transcoder";
import { onObjectFinalized } from "firebase-functions/v2/storage";

initializeApp();

const firestore = new Firestore();
const storage = new Storage();
const transcoderServiceClient = new TranscoderServiceClient();

const rawVideoBucketName = "foreverstream-raw-videos";
const processedVideoBucketName = "foreverstream-processed-videos";
const location = "us-central1";

const videoCollectionId = "videos";

interface UploadRequest {
  fileExtension: string;
  metadata: {
    title: string;
    description: string;
  };
}

export const createUser = functions.auth.user().onCreate((user) => {
  const userInfo = {
    uid: user.uid,
    email: user.email,
    photoUrl: user.photoURL,
  };

  firestore.collection("users").doc(user.uid).set(userInfo);
  logger.info(`User Created: ${JSON.stringify(userInfo)}`);
  return;
});

export const generateUploadUrl = onCall(
  { maxInstances: 1 },
  async (request) => {
    // Check if user is authenticated
    if (!request.auth) {
      throw new functions.https.HttpsError(
        "failed-precondition",
        "The function must be called while authenticated"
      );
    }

    const timestamp = Date.now();

    const auth = request.auth;
    const data = request.data as UploadRequest;
    const bucket = storage.bucket(rawVideoBucketName);
    const fileName = `${auth.uid}-${timestamp}.${data.fileExtension}`;
    const documentId = `${auth.uid}-${timestamp}`;
    const file = bucket.file(fileName);

    const videoDoc = {
      id: documentId,
      uid: auth.uid,
      fileName: fileName,
      status: "uploaded",
      title: data.metadata.title,
      description: data.metadata.description,
      UploadedAt: new Date().toISOString(),
    };

    await firestore.collection(videoCollectionId).doc(documentId).set(videoDoc);
    logger.info(`Created Firestore document with ID: ${documentId}`);

    const [url] = await file.getSignedUrl({
      version: "v4",
      action: "write",
      expires: Date.now() + 15 * 60 * 1000, // 15 minutes
    });

    logger.info(`Generated upload URL for ${fileName}`);

    return { url, fileName, documentId };
  }
);

export const getVideos = onCall({ maxInstances: 1 }, async () => {
  const snapshot = await firestore
    .collection(videoCollectionId)
    .limit(10)
    .get();
  return snapshot.docs.map((doc) => doc.data());
});

export const createTranscodingJob = onObjectFinalized(
  {
    bucket: rawVideoBucketName,
    region: location,
  },
  async (object) => {
    const videoId = object.data.name.split(".")[0];

    try {
      const inputUri = `gs://${object.data.bucket}/${object.data.name}`;
      const outputUri = `gs://${processedVideoBucketName}/${videoId}/`;

      const request = {
        parent: transcoderServiceClient.locationPath(
          process.env.GOOGLE_CLOUD_PROJECT_ID! ||
            functions.config().google.project_id,
          location
        ),
        job: {
          inputUri: inputUri,
          outputUri: outputUri,
          config: {
            elementaryStreams: [
              {
                key: "video-sd",
                videoStream: {
                  h264: {
                    heightPixels: 360,
                    widthPixels: 640,
                    bitrateBps: 550000,
                    frameRate: 60,
                  },
                },
              },
              {
                key: "video-hd",
                videoStream: {
                  h264: {
                    heightPixels: 720,
                    widthPixels: 1280,
                    bitrateBps: 2500000,
                    frameRate: 60,
                  },
                },
              },
              {
                key: "audio-stream",
                audioStream: {
                  codec: "aac",
                  bitrateBps: 64000,
                },
              },
            ],
            muxStreams: [
              {
                key: "sd",
                container: "fmp4",
                elementaryStreams: ["video-sd"],
              },
              {
                key: "hd",
                container: "fmp4",
                elementaryStreams: ["video-hd"],
              },
              {
                key: "audio",
                container: "fmp4",
                elementaryStreams: ["audio-stream"],
              },
            ],
            manifests: [
              {
                fileName: "manifest.mpd",
                type: "DASH",
                muxStreams: ["sd", "hd", "audio"],
              },
            ],
          },
        },
      } as any;

      const response = await transcoderServiceClient.createJob(request);

      // Update Firestore
      await firestore.collection(videoCollectionId).doc(videoId).update({
        status: "processing",
        transcodingJobId: response[0].name,
      });
    } catch (error: any) {
      console.error("Error creating transcoding job:", error);
      await firestore.collection(videoCollectionId).doc(videoId).update({
        status: "error",
        error: error.message,
      });
      throw error;
    }
  }
);

export const handleTranscodedVideo = onObjectFinalized(
  {
    bucket: processedVideoBucketName,
    region: location,
  },
  async (object) => {
    console.log("File created in processed bucket:", object.data.name);
    // Only proceed if this is a manifest file
    if (!object.data.name.endsWith("manifest.mpd")) return;

    const videoId = object.data.name.split("/")[0];

    try {
      // Update the video document in Firestore
      await firestore
        .collection("videos")
        .doc(videoId)
        .update({
          status: "processed",
          processedUrl: `https://storage.googleapis.com/${processedVideoBucketName}/${videoId}/manifest.mpd`,
          processedAt: new Date().toISOString(),
        });

      console.log(`Updated video ${videoId} status to processed`);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error occurred";

      console.error("Error updating transcoded video status:", errorMessage);
      await firestore.collection(videoCollectionId).doc(videoId).update({
        status: "error",
        error: errorMessage,
      });
      throw error;
    }
  }
);
